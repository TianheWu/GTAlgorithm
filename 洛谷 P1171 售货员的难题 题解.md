## 洛谷 P1171 售货员的难题 题解

### 题目解读

给定n个村庄，有一个售货员要走遍各个村庄，且每个村庄只走一次，最后返回该村庄，求最短的路径。

### 解法：动态规划

这道题我们可以利用穷举法，穷举出所有路径，然后选择一条最短的路径。但是这样的话时间复杂度将会达到O(n!)，显然是不符合要求的，为了降低时间复杂度，我们可以选择将空间换时间。我们分析该问题是否具有最优子结构也就是是否可以利用动态规划来进行求解。

我们要走的路径为s, s1, s2, s3 ... s，当我们走到s1时，如果s到s1时已经是最短路径，那么该问题就转化为求s1到s的最短路径，显然这是符合最优子结构的，我们可以利用动态规划进行问题的求解。

对于动态规划问题，我们需要记录每一个状态，但是这道题最多有20个状态，也就是说需要20多维数组才能记录，因此我们要考虑进行状态压缩。我们可以利用二进制思想来进行状态压缩，从而不用开辟那么多维的数组。我们构造最优值函数：

<img src="C:\Users\Tianhe Wu\AppData\Roaming\Typora\typora-user-images\image-20201124185336359.png" alt="image-20201124185336359" style="zoom: 67%;" />

其中我们可以用二进制表示V，例如现在有5个村庄，我们用11111表示经过了5个村庄，10001表示经过了第一个和第5个村庄没有经过2，3，4村庄，因此我们只需找到:

<img src="C:\Users\Tianhe Wu\AppData\Roaming\Typora\typora-user-images\image-20201124190310273.png" alt="image-20201124190310273" style="zoom:67%;" />

即可。

#### 数据结构与算法定义

```c++
int dp[1 << 20][20], w[20][20];
```

我们可以定义dp[i] [j]来表示i状态下到达村庄j的最短路径距离。w二维数组中存储i到j的距离。

接下来我们遍历每一个状态i，再遍历每一个村庄k去判断k是否能去访问别的村庄，如果可以的话，遍历每一个村庄，判断该村庄是否能被访问即可。最后只需要在状态所有村庄遍历后回到原始点即可。

#### 代码

```c++
#include <bits/stdc++.h>
using namespace std;

int N;
int dp[1 << 20][20], w[20][20];

int main() {
    cin >> N;
    for (int i = 0; i < N; i++)
        for (int j = 0; j < N; j++)
            cin >> w[i][j];
    memset(dp, 0x3f, sizeof(dp));
    int INF = dp[1][0];
    dp[1][0] = 0;
    for (int i = 1; i < 1 << N; i += 2) {  // 第一个村庄永远是访问过的状态，因此加2即可
        for (int k = 0; k < N; k++) {
            if (dp[i][k] < INF) {   // 点k是否能去访问别的城市
                for (int j = 0; j < N; j++) {
                    if (!((1 << j) & i)) { // 访问的村庄是否已经被访问过
                        if (dp[i | (1 << j)][j] > dp[i][k] + w[k][j]) { // 将状态i的第j位设置为1，更新最短路
                            dp[i | (1 << j)][j] = dp[i][k] + w[k][j];
                        }
                    }
                }
            }
        }
    }
    int min_val = INT_MAX;
    for (int i = 0; i < N; i++) {
        if (min_val > dp[(1 << N) - 1][i] + w[i][0]) {
            min_val = dp[(1 << N) - 1][i] + w[i][0];
        }
    }
    cout << min_val << "\n";
    return 0;
}
```



#### 复杂度分析：

时间复杂度：O(N^2)

空间复杂度：O(2^N*N)

#### 作者：吴天鹤